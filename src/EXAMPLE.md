# Clean Architecture - Complete Example

This document shows a complete example of implementing a User feature using Clean Architecture.

## File Structure

```
src/
├── domain/
│   ├── entities/
│   │   └── User.ts
│   ├── repositories/
│   │   └── UserRepository.ts
│   └── use-cases/
│       ├── GetUserUseCase.ts
│       └── CreateUserUseCase.ts
├── application/
│   ├── dtos/
│   │   └── UserDTO.ts
│   └── services/
│       └── UserService.ts
├── infrastructure/
│   ├── api/
│   │   └── UserApiClient.ts
│   └── repositories/
│       └── UserRepositoryImpl.ts
└── presentation/
    ├── components/
    │   └── features/
    │       └── user/
    │           ├── UserCard.tsx
    │           └── UserList.tsx
    ├── hooks/
    │   └── useUser.ts
    └── pages/
        └── UserPage.tsx
```

## Implementation

### 1. Domain Entity
```typescript
// src/domain/entities/User.ts
export interface User {
  id: string;
  name: string;
  email: string;
  createdAt: Date;
  updatedAt: Date;
}

export class UserEntity implements User {
  constructor(
    public id: string,
    public name: string,
    public email: string,
    public createdAt: Date,
    public updatedAt: Date
  ) {
    this.validate();
  }

  private validate(): void {
    if (!this.email.includes('@')) {
      throw new Error('Invalid email format');
    }
    if (this.name.length < 2) {
      throw new Error('Name must be at least 2 characters');
    }
  }

  get displayName(): string {
    return `${this.name} (${this.email})`;
  }
}
```

### 2. Domain Repository Interface
```typescript
// src/domain/repositories/UserRepository.ts
import { User } from '@domain/entities/User';

export interface UserRepository {
  findById(id: string): Promise<User | null>;
  findAll(): Promise<User[]>;
  create(user: Omit<User, 'id' | 'createdAt' | 'updatedAt'>): Promise<User>;
  update(id: string, user: Partial<User>): Promise<User>;
  delete(id: string): Promise<void>;
}
```

### 3. Domain Use Cases
```typescript
// src/domain/use-cases/GetUserUseCase.ts
import { User } from '@domain/entities/User';
import { UserRepository } from '@domain/repositories/UserRepository';

export class GetUserUseCase {
  constructor(private userRepository: UserRepository) {}

  async execute(userId: string): Promise<User> {
    const user = await this.userRepository.findById(userId);
    if (!user) {
      throw new Error('User not found');
    }
    return user;
  }
}

// src/domain/use-cases/CreateUserUseCase.ts
import { User, UserEntity } from '@domain/entities/User';
import { UserRepository } from '@domain/repositories/UserRepository';

export class CreateUserUseCase {
  constructor(private userRepository: UserRepository) {}

  async execute(data: { name: string; email: string }): Promise<User> {
    // Business validation
    const now = new Date();
    const user = new UserEntity(
      '', // ID will be generated by repository
      data.name,
      data.email,
      now,
      now
    );

    return await this.userRepository.create(user);
  }
}
```

### 4. Application DTO
```typescript
// src/application/dtos/UserDTO.ts
export interface UserDTO {
  id: string;
  name: string;
  email: string;
  createdAt: string;
  updatedAt: string;
}

export interface CreateUserDTO {
  name: string;
  email: string;
}

export interface UpdateUserDTO {
  name?: string;
  email?: string;
}
```

### 5. Application Service
```typescript
// src/application/services/UserService.ts
import { GetUserUseCase } from '@domain/use-cases/GetUserUseCase';
import { CreateUserUseCase } from '@domain/use-cases/CreateUserUseCase';
import { User } from '@domain/entities/User';
import { CreateUserDTO, UserDTO } from '@application/dtos/UserDTO';

export class UserService {
  constructor(
    private getUserUseCase: GetUserUseCase,
    private createUserUseCase: CreateUserUseCase
  ) {}

  async getUserById(userId: string): Promise<UserDTO> {
    const user = await this.getUserUseCase.execute(userId);
    return this.mapToDTO(user);
  }

  async createUser(data: CreateUserDTO): Promise<UserDTO> {
    const user = await this.createUserUseCase.execute(data);
    return this.mapToDTO(user);
  }

  private mapToDTO(user: User): UserDTO {
    return {
      id: user.id,
      name: user.name,
      email: user.email,
      createdAt: user.createdAt.toISOString(),
      updatedAt: user.updatedAt.toISOString(),
    };
  }
}
```

### 6. Infrastructure API Client
```typescript
// src/infrastructure/api/UserApiClient.ts
import { UserDTO, CreateUserDTO } from '@application/dtos/UserDTO';

export class UserApiClient {
  private baseUrl = import.meta.env.VITE_API_URL || 'http://localhost:3000';

  async fetchUser(id: string): Promise<UserDTO> {
    const response = await fetch(`${this.baseUrl}/users/${id}`);
    if (!response.ok) {
      throw new Error(`Failed to fetch user: ${response.statusText}`);
    }
    return response.json();
  }

  async fetchUsers(): Promise<UserDTO[]> {
    const response = await fetch(`${this.baseUrl}/users`);
    if (!response.ok) {
      throw new Error(`Failed to fetch users: ${response.statusText}`);
    }
    return response.json();
  }

  async createUser(data: CreateUserDTO): Promise<UserDTO> {
    const response = await fetch(`${this.baseUrl}/users`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data),
    });
    if (!response.ok) {
      throw new Error(`Failed to create user: ${response.statusText}`);
    }
    return response.json();
  }

  async deleteUser(id: string): Promise<void> {
    const response = await fetch(`${this.baseUrl}/users/${id}`, {
      method: 'DELETE',
    });
    if (!response.ok) {
      throw new Error(`Failed to delete user: ${response.statusText}`);
    }
  }
}
```

### 7. Infrastructure Repository Implementation
```typescript
// src/infrastructure/repositories/UserRepositoryImpl.ts
import { User, UserEntity } from '@domain/entities/User';
import { UserRepository } from '@domain/repositories/UserRepository';
import { UserApiClient } from '@infrastructure/api/UserApiClient';
import { UserDTO } from '@application/dtos/UserDTO';

export class UserRepositoryImpl implements UserRepository {
  constructor(private apiClient: UserApiClient) {}

  async findById(id: string): Promise<User | null> {
    try {
      const dto = await this.apiClient.fetchUser(id);
      return this.mapDtoToEntity(dto);
    } catch (error) {
      console.error('Error fetching user:', error);
      return null;
    }
  }

  async findAll(): Promise<User[]> {
    const dtos = await this.apiClient.fetchUsers();
    return dtos.map(dto => this.mapDtoToEntity(dto));
  }

  async create(user: Omit<User, 'id' | 'createdAt' | 'updatedAt'>): Promise<User> {
    const dto = await this.apiClient.createUser({
      name: user.name,
      email: user.email,
    });
    return this.mapDtoToEntity(dto);
  }

  async update(id: string, user: Partial<User>): Promise<User> {
    // Implementation similar to create
    throw new Error('Not implemented');
  }

  async delete(id: string): Promise<void> {
    await this.apiClient.deleteUser(id);
  }

  private mapDtoToEntity(dto: UserDTO): User {
    return new UserEntity(
      dto.id,
      dto.name,
      dto.email,
      new Date(dto.createdAt),
      new Date(dto.updatedAt)
    );
  }
}
```

### 8. Presentation Hook
```typescript
// src/presentation/hooks/useUser.ts
import { useState, useEffect } from 'react';
import { UserDTO } from '@application/dtos/UserDTO';
import { useServices } from '@presentation/contexts/ServicesContext';

export const useUser = (userId: string) => {
  const { userService } = useServices();
  const [user, setUser] = useState<UserDTO | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const loadUser = async () => {
      try {
        setLoading(true);
        const userData = await userService.getUserById(userId);
        setUser(userData);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Unknown error');
      } finally {
        setLoading(false);
      }
    };

    loadUser();
  }, [userId, userService]);

  return { user, loading, error };
};
```

### 9. Presentation Component
```tsx
// src/presentation/components/features/user/UserCard.tsx
import { UserDTO } from '@application/dtos/UserDTO';
import './UserCard.css';

interface UserCardProps {
  user: UserDTO;
  onDelete?: () => void;
}

export const UserCard: React.FC<UserCardProps> = ({ user, onDelete }) => {
  return (
    <div className="user-card">
      <h3>{user.name}</h3>
      <p>{user.email}</p>
      <small>Joined: {new Date(user.createdAt).toLocaleDateString()}</small>
      {onDelete && (
        <button onClick={onDelete} className="btn-delete">
          Delete
        </button>
      )}
    </div>
  );
};
```

### 10. Presentation Page
```tsx
// src/presentation/pages/UserPage.tsx
import { useParams } from 'react-router-dom';
import { useUser } from '@presentation/hooks/useUser';
import { UserCard } from '@presentation/components/features/user/UserCard';

export const UserPage: React.FC = () => {
  const { userId } = useParams<{ userId: string }>();
  const { user, loading, error } = useUser(userId!);

  if (loading) {
    return <div className="loading">Loading user...</div>;
  }

  if (error) {
    return <div className="error">Error: {error}</div>;
  }

  if (!user) {
    return <div className="not-found">User not found</div>;
  }

  return (
    <div className="user-page">
      <h1>User Profile</h1>
      <UserCard user={user} />
    </div>
  );
};
```

### 11. Dependency Injection (Context)
```tsx
// src/presentation/contexts/ServicesContext.tsx
import { createContext, useContext, ReactNode } from 'react';
import { UserService } from '@application/services/UserService';
import { GetUserUseCase } from '@domain/use-cases/GetUserUseCase';
import { CreateUserUseCase } from '@domain/use-cases/CreateUserUseCase';
import { UserRepositoryImpl } from '@infrastructure/repositories/UserRepositoryImpl';
import { UserApiClient } from '@infrastructure/api/UserApiClient';

interface Services {
  userService: UserService;
}

const ServicesContext = createContext<Services | undefined>(undefined);

export const ServicesProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  // Initialize dependencies
  const userApiClient = new UserApiClient();
  const userRepository = new UserRepositoryImpl(userApiClient);
  const getUserUseCase = new GetUserUseCase(userRepository);
  const createUserUseCase = new CreateUserUseCase(userRepository);
  const userService = new UserService(getUserUseCase, createUserUseCase);

  const services = {
    userService,
  };

  return (
    <ServicesContext.Provider value={services}>
      {children}
    </ServicesContext.Provider>
  );
};

export const useServices = () => {
  const context = useContext(ServicesContext);
  if (!context) {
    throw new Error('useServices must be used within ServicesProvider');
  }
  return context;
};
```

### 12. App Setup
```tsx
// src/App.tsx
import { BrowserRouter, Routes, Route } from 'react-router-dom';
import { ServicesProvider } from '@presentation/contexts/ServicesContext';
import { UserPage } from '@presentation/pages/UserPage';

function App() {
  return (
    <ServicesProvider>
      <BrowserRouter>
        <Routes>
          <Route path="/users/:userId" element={<UserPage />} />
        </Routes>
      </BrowserRouter>
    </ServicesProvider>
  );
}

export default App;
```

## Key Takeaways

1. **Dependencies flow inward**: UI → Infrastructure/Application → Domain
2. **Domain is pure**: No external dependencies, just business logic
3. **Interfaces define contracts**: Repository interfaces in domain, implementations in infrastructure
4. **Services coordinate**: Application services orchestrate use cases
5. **Context provides injection**: React Context provides services to components
6. **Clean separation**: Each layer has a clear, single responsibility

This structure makes the code:
- **Testable**: Easy to mock dependencies
- **Maintainable**: Clear where each piece of logic belongs
- **Flexible**: Easy to swap implementations
- **Scalable**: Organized structure that grows well
